<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Шейный отдел — генератор формулировок v6-fixed</title>
  <style>
    :root{ --border:#e5e7eb; --bg:#fff; --bgm:#f9fafb; --text:#111827; --r:12px; }
    body{ font-family:"Trebuchet MS",Arial,sans-serif; color:var(--text); margin:12px; font-size:14px; line-height:1.45; }
    .controls{ display:flex; gap:8px; flex-wrap:wrap; margin:10px 0; }
    button{ padding:8px 12px; border:1px solid var(--border); border-radius:var(--r); background:#fff; cursor:pointer; }
    button:hover{ background:var(--bgm); }
    .table-wrap{ overflow-x:auto; -webkit-overflow-scrolling:touch; border:1px solid var(--border); border-radius:var(--r); }
    table{ border-collapse:collapse; min-width:1020px; width:100%; }
    th,td{ border-bottom:1px solid var(--border); padding:8px; vertical-align:top; text-align:left; }
    th{ background:var(--bgm); }
    .checkcol{ display:flex; flex-direction:column; gap:6px; max-height:180px; overflow:auto; }
    .radiocol{ display:flex; flex-direction:column; gap:6px; max-height:180px; overflow:auto; }
    th.col1,td.col1{ width:160px; }
    th.col2,td.col2{ width:180px; }
    th.col5,td.col5{ width:200px; }
    .paragraphs{ border:1px dashed var(--border); border-radius:var(--r); padding:10px; margin-top:10px; background:#fff; }
    .para{ background:var(--bgm); border-radius:10px; padding:8px; margin:6px 0; }
    .conclusion{ border:1px solid var(--border); border-radius:var(--r); padding:10px; margin-top:14px; background:#fff; }
    .conclusion h4{ margin:0 0 6px 0; }
  </style>
  <script src="//js.jotform.com/JotFormCustomWidget.min.js"></script>
</head>
<body>
  <h3>Шейный отдел — генератор формулировок v6‑fixed</h3>
  <div class="controls">
    <button id="addRow" type="button">+ Добавить строку</button>
    <button id="clearRows" type="button">Очистить</button>
  </div>

  <div class="table-wrap">
    <table>
      <thead>
        <tr>
          <th class="col1">Сегменты</th>
          <th class="col2">Вид</th>
          <th>Зоны/секторы</th>
          <th>Глубина, мм</th>
          <th class="col5">Фиброзное кольцо</th>
          <th>Миграция</th>
          <th>Дополнительно</th>
          <th>Действия</th>
        </tr>
      </thead>
      <tbody id="body"></tbody>
    </table>
  </div>

  <h4>Сформированные абзацы</h4>
  <div id="paragraphs" class="paragraphs"></div>

  <div class="conclusion">
    <h4>МП диски — заключение</h4>
    <div id="conclusionText" class="muted"></div>
  </div>

  <script>
    const LEVELS = ["C1-2","C2-3","C3-4","C4-5","C5-6","C6-7","C7-Th1","Th1-2"];
    const TYPES = ["диффузное выстояние (выбухание)","широкая протрузия","фокальная протрузия","экструзия","фиброзированная грыжа"];
    const TYPES_PL = {
      "диффузное выстояние (выбухание)":"диффузные выстояния (выбухания)",
      "широкая протрузия":"широкие протрузии",
      "фокальная протрузия":"фокальные протрузии",
      "экструзия":"экструзии",
      "фиброзированная грыжа":"фиброзированные грыжи"
    };
    const BASE_PL = {"фораминальная":"фораминальные","субартикулярная":"субартикулярные","парамедианная":"парамедианные","медианная":"медианные","по широкой дуге":"по широкой дуге"};
    const ZONES = [
      ["правая фораминальная","фораминальная","правая"],
      ["правая субартикулярная","субартикулярная","правая"],
      ["правая парамедианная","парамедианная","правая"],
      ["медианная","медианная",null],
      ["левая парамедианная","парамедианная","левая"],
      ["левая субартикулярная","субартикулярная","левая"],
      ["левая фораминальная","фораминальная","левая"],
      ["по широкой дуге","по широкой дуге",null]
    ];
    const RING = ["без повреждения","частичное повреждение","разрыв","фиброзирование","вероятный разрыв"];
    const MIGRATION = ["без миграции","минимальная каудальная","минимальная краниальная","краниальная педикулярная","краниальная субпедикулярная","каудальная супрапедикулярная","каудальная педикулярная","каудальная субпедикулярная","краниальная и каудальная"];
    const EXTRA = [
      ["остеофиты прикрывают выстояние","остеофиты смежных позвонков, прикрывающие выстояние диска/дисков"],
      ["умеренная деформ. позв. канала","умеренная деформация позвоночного канала"],
      ["компрессия корешков нервов","компрессия корешков нервов"],
      ["латерализация экструзии","признаки латерализации смещенной ткани диска"],
      ["секвестрация","секвестрация грыжевой ткани"],
      ["компрессия спинного мозга","компрессия спинного мозга"],
      ["компрессия и отёк спинного мозга","компрессия и отёк спинного мозга"]
    ];

    function el(tag, attrs={}, children=[]){ const e=document.createElement(tag); for(const[k,v] of Object.entries(attrs)){ if(k==="class") e.className=v; else if(k==="text") e.textContent=v; else e.setAttribute(k,v);} children.forEach(c=>e.appendChild(c)); return e; }
    function checkboxCol(name, options){ const w=el("div",{class:"checkcol"}); options.forEach((opt,i)=>{ const label = Array.isArray(opt)?opt[0]:opt; const id=name+"_"+i+"_"+Math.random().toString(36).slice(2,6); const cb=el("input",{type:"checkbox",id,name,value:label}); const lab=el("label",{"for":id},[document.createTextNode(label)]); w.appendChild(el("div",{},[cb,lab])); }); return w; }
    function radioCol(name, options){ const w=el("div",{class:"radiocol"}); options.forEach((opt,i)=>{ const val = Array.isArray(opt)?opt[0]:opt; const id=name+"_"+i+"_"+Math.random().toString(36).slice(2,6); const rb=el("input",{type:"radio",id,name,value:val}); const lab=el("label",{"for":id},[document.createTextNode(val)]); w.appendChild(el("div",{},[rb,lab])); }); return w; }

    function getCheckedValues(scope, selector){ return [...scope.querySelectorAll(selector+":checked")].map(x=>x.value); }
    function getRadioValue(scope, name){ const el = scope.querySelector(`input[type="radio"][name="${name}"]:checked`); return el?el.value:""; }
    function listJoin(arr){ if(arr.length<=1) return arr.join(""); return arr.slice(0,-1).join(", ")+" и "+arr[arr.length-1]; }
    function parseZone(label){ const z = ZONES.find(z=>z[0]===label); return z? {side:z[2], base:z[1]} : {side:null, base:label}; }

    function zonesPhrase(zLabels, segCount){
      if(!zLabels || !zLabels.length) return "";
      const zs = zLabels.map(parseZone);
      if(segCount===1 && zs.length===2){
        const [z1,z2] = zs;
        const opposite = (z1.side && z2.side) && ((z1.side==="правая"&&z2.side==="левая")||(z1.side==="левая"&&z2.side==="правая"));
        if(opposite){
          if(z1.base===z2.base){
            const basePl = BASE_PL[z1.base] || (z1.base + "е");
            return `правая и левая ${basePl}`;
          }else{
            return `${z1.side} ${z1.base} и ${z2.side} ${z2.base}`;
          }
        }
      }
      if(segCount===1){
        const items = zs.map(z=> z.side ? `${z.side} ${z.base}` : z.base);
        return listJoin(items);
      } else {
        const items = zs.map(z=>{
          if(z.side){
            const sidePl = z.side==="правая" ? "правые" : "левые";
            const basePl = BASE_PL[z.base] || (z.base + "е");
            return `${sidePl} ${basePl}`;
          }
          return BASE_PL[z.base] || z.base;
        });
        return listJoin(items);
      }
    }

    function depthChunk(depth, willContinue){
      if(!depth) return "";
      const num = parseFloat((depth+"").replace(",", "."));
      if(!isFinite(num)) return "";
      const phrase = (num <= 1.5) ? ` глубиной не более ${depth} мм` : ` глубиной до ${depth} мм`;
      return phrase + (willContinue ? "," : "");
    }

    function ringInline(ring, segsCount){
      if(!ring) return "";
      if(ring==="без повреждения") return " без признаков повреждения фиброзного кольца";
      if(ring==="частичное повреждение") return " с признаками частичного повреждения фиброзного кольца";
      if(ring==="разрыв") return " с признаками разрыва фиброзного кольца";
      if(ring==="вероятный разрыв"){ const noun = segsCount>1? "дисков" : "диска"; return `, вероятен разрыв фиброзного кольца ${noun}`; }
      return ""; // фиброзирование обрабатываем отдельно (после мм,)
    }

    function lowerFirst(s){ return s? s.charAt(0).toLowerCase()+s.slice(1) : s; }
    function extrasForComma(extras, segsCount){
      if(!extras || !extras.length) return [];
      const full = extras.map(s=> (EXTRA.find(p=>p[0]===s)||[null,s])[1]);
      return full.map(f=>{
        if(f.startsWith("остеофиты")){
          const noun = segsCount>1? "выстояния дисков" : "выстояние диска";
          f = f.replace("выстояние диска/дисков", noun);
        }
        return lowerFirst(f);
      });
    }

    function migrationLead(mig){
      if(!mig || mig==="без миграции") return null;
      if(mig==="минимальная каудальная" || mig==="минимальная краниальная") return `Отмечается ${mig} миграция ткани диска`;
      if(mig==="краниальная и каудальная") return "Отмечаются краниальная и каудальная миграции ткани диска";
      const levelMap = {"краниальная педикулярная":"до педикулярного уровня","краниальная субпедикулярная":"до субпедикулярного уровня","каудальная супрапедикулярная":"до супрапедикулярного уровня","каудальная педикулярная":"до педикулярного уровня","каудальная субпедикулярная":"до субпедикулярного уровня"};
      const dir = mig.split(" ")[0]; const to = levelMap[mig] || "";
      return `Отмечается ${dir} миграция ткани диска${to?(" " + to):""}`;
    }

    function buildConclusion(rows){
      // Gather selected segments, types, depths, migration presence, extras compressions/sequestration
      const segSet = new Set();
      const protrusions = []; // {seg, depth}
      const extrusions = []; // {seg, depth}
      let anyMigrationDir = new Set();
      let anyCompression = false;
      let anyCordCompression = false;
      let anySequestration = false;

      rows.forEach(r=>{
        (r.levels||[]).forEach(s=> segSet.add(s));
        const depth = parseFloat((r.depth||"").replace(",", ".")) || 0;
        const hasProtr = (r.type && r.type.includes("протрузия"));
        const hasExtr = (r.type === "экструзия");
        if(hasProtr) protrusions.push({seg: (r.levels||[]).join(", "), depth});
        if(hasExtr) extrusions.push({seg: (r.levels||[]).join(", "), depth});

        if(r.migration && r.migration!=="без миграции"){
          if(r.migration.includes("краниальная")) anyMigrationDir.add("краниальная");
          if(r.migration.includes("каудальная")) anyMigrationDir.add("каудальная");
        }

        (r.extra||[]).forEach(ui=>{
          const full = (EXTRA.find(p=>p[0]===ui)||[null,ui])[1];
          if(full.includes("компрессия спинного мозга")) anyCordCompression = true;
          if(full.includes("компрессия корешков")) anyCompression = true;
          if(full.includes("секвестрация")) anySequestration = true;
        });
      });

      const segCount = segSet.size;
      const intro = segCount<=2 ? "Признаки дисковой дегенерации" : "Признаки распространенной дисковой дегенерации";

      let middle = "";
      if(extrusions.length && protrusions.length){
        // both present
        const firstExtr = extrusions[0];
        middle = ` с формированием экструзии в сегменте ${firstExtr.seg}, а также экструзий`;
      } else if(extrusions.length){
        if(extrusions.length===1){
          middle = ` с формированием экструзии в сегменте ${extrusions[0].seg}`;
        } else {
          const list = extrusions.map(x=>x.seg);
          middle = ` с формированием экструзий в сегментах ${listJoin(list)}`;
        }
      } else if(protrusions.length){
        // pick max depth
        const maxd = Math.max(...protrusions.map(x=>x.depth));
        const maxSegs = protrusions.filter(x=>x.depth===maxd).map(x=>x.seg);
        middle = ` с формированием протрузий дисков, более выраженной в ${listJoin(maxSegs)}`;
      }

      // tails
      let tails = [];
      if(anyMigrationDir.size){
        const dirs = Array.from(anyMigrationDir);
        tails.push("с " + (dirs.length===2 ? "краниальной и каудальной" : dirs[0]) + " миграцией");
      }
      if(anyCompression) tails.push("компрессией корешков нервов");
      if(anyCordCompression) tails.push("компрессией спинного мозга");
      if(anySequestration) tails.push("секвестрацией грыжевой ткани");

      const conclusion = intro + (middle||"") + (tails.length? (", " + tails.join(", ")) : "") + ".";
      return conclusion;
    }

    // UI builders again (after function defs for use)
    function checkboxCol(name, options){ const w=document.createElement("div"); w.className="checkcol"; options.forEach((opt,i)=>{ const label = Array.isArray(opt)?opt[0]:opt; const id=name+"_"+i+"_"+Math.random().toString(36).slice(2,6); const cb=document.createElement("input"); cb.type="checkbox"; cb.id=id; cb.name=name; cb.value=label; const lab=document.createElement("label"); lab.setAttribute("for",id); lab.textContent=label; const row=document.createElement("div"); row.appendChild(cb); row.appendChild(lab); w.appendChild(row); }); return w; }
    function radioCol(name, options){ const w=document.createElement("div"); w.className="radiocol"; options.forEach((opt,i)=>{ const val = Array.isArray(opt)?opt[0]:opt; const id=name+"_"+i+"_"+Math.random().toString(36).slice(2,6); const rb=document.createElement("input"); rb.type="radio"; rb.id=id; rb.name=name; rb.value=val; const lab=document.createElement("label"); lab.setAttribute("for",id); lab.textContent=val; const row=document.createElement("div"); row.appendChild(rb); row.appendChild(lab); w.appendChild(row); }); return w; }

    function getRows(){ return [...document.querySelectorAll("#body tr")].map(tr=>({levels:getCheckedValues(tr,'input[type="checkbox"][name="levels"]'),type:getRadioValue(tr,'type'),zones:getCheckedValues(tr,'input[type="checkbox"][name="zones"]'),depth:tr.querySelector('input[type="number"]').value,ring:getRadioValue(tr,'ring'),migration:getRadioValue(tr,'migration'),extra:getCheckedValues(tr,'input[type="checkbox"][name="extra"]')})); }

    function buildParagraph(row){
      const segPlural = row.levels.length>1;
      const anyPlural = segPlural || row.zones.length>1;
      const segWord = segPlural? "сегментах" : "сегменте";
      const verb = anyPlural? "определяются" : "определяется";
      const typeWord = anyPlural? (TYPES_PL[row.type]||row.type) : row.type;

      const zonesTxt = zonesPhrase(row.zones, row.levels.length);
      const willCont = !!row.ring || (row.migration && row.migration!=="без миграции") || (row.ring==="фиброзирование"); // fibroz continues
      let depthTxt = depthChunk(row.depth, willCont);

      // Insert MR-signal phrase right after mm, for fibroz
      if(row.ring==="фиброзирование"){
        const noun = row.levels.length>1? "дисков" : "диска";
        depthTxt += ` МР-сигнал ${noun} низкий`;
        // if continues further with ringInline or migration/extras, add comma after inserted phrase
        if((row.migration && row.migration!=="без миграции") || row.ring!=="фиброзирование"){
          depthTxt += ",";
        }
      }

      const ringAdd = ringInline(row.ring, row.levels.length);

      let first = `В ${segWord} ${listJoin(row.levels)} ${verb}${zonesTxt?(" "+zonesTxt):""} ${typeWord}${depthTxt}${ringAdd}.`;
      first = first.replace(/,\s*,/g,", ").replace(/\s+/g," ").replace(/ \./g,".").trim();

      // Build second sentence (migration + extras combined)
      const extrasList = extrasForComma(row.extra, row.levels.length);
      let second = null;
      if(row.migration && row.migration!=="без миграции"){
        const lead = migrationLead(row.migration);
        second = lead + (extrasList.length? ", " + extrasList.join(", ") : "") + ".";
      } else if(extrasList.length){
        const verb2 = extrasList.length>1 ? "Отмечаются " : "Отмечается ";
        second = verb2 + extrasList.join(", ") + ".";
      }

      const sentences = [first];
      if(second) sentences.push(second);

      return { text: sentences.join(" "), html: `<div class="para">${sentences.map(s=>`<span>${s}</span>`).join(" ")}</div>` };
    }

    function render(){
      const rows = getRows();
      const paragraphs = rows.map(buildParagraph);
      const wrap = document.getElementById("paragraphs");
      wrap.innerHTML = "";
      paragraphs.forEach(p=> wrap.insertAdjacentHTML("beforeend", p.html));

      const conclusion = buildConclusion(rows);
      document.getElementById("conclusionText").textContent = conclusion;

      const value = { rows, paragraphs, text: paragraphs.map(p=>p.text).join("\n\n"), conclusion };
      if(window.JFCustomWidget){
        JFCustomWidget.sendData({ value: JSON.stringify(value) });
        if(JFCustomWidget.setHeight){ setTimeout(()=>JFCustomWidget.setHeight(document.body.scrollHeight+40),0); }
      }
    }

    document.getElementById("addRow").onclick = ()=>{ document.getElementById("body").appendChild(makeRow()); render(); };
    document.getElementById("clearRows").onclick = ()=>{ document.getElementById("body").innerHTML=""; render(); };

    function makeRow(preset){
      const tr = document.createElement("tr");
      const c1 = el("td",{class:"col1"},[checkboxCol("levels", LEVELS)]);
      const c2 = el("td",{class:"col2"},[radioCol("type", TYPES)]);
      const c3 = el("td",{},[checkboxCol("zones", ZONES.map(z=>z[0]))]);
      const depth = el("input",{type:"number", step:"0.5", min:"0", placeholder:"мм"});
      const c4 = el("td",{},[depth]);
      const c5 = el("td",{class:"col5"},[radioCol("ring", RING)]);
      const c6 = el("td",{},[radioCol("migration", MIGRATION)]);
      const c7 = el("td",{},[checkboxCol("extra", EXTRA.map(p=>p[0]))]);
      const del = el("button",{type:"button",text:"Удалить"});
      del.onclick = ()=>{ tr.remove(); render(); };
      const c8 = el("td",{},[del]);

      tr.appendChild(c1); tr.appendChild(c2); tr.appendChild(c3); tr.appendChild(c4); tr.appendChild(c5); tr.appendChild(c6); tr.appendChild(c7); tr.appendChild(c8);

      if(preset){
        [...tr.querySelectorAll('input[type="checkbox"][name="levels"]')].forEach(cb=>{ if((preset.levels||[]).includes(cb.value)) cb.checked=true; });
        if(preset.type){ const rb=tr.querySelector(`input[type="radio"][name="type"][value="${preset.type}"]`); if(rb) rb.checked=true; }
        [...tr.querySelectorAll('input[type="checkbox"][name="zones"]')].forEach(cb=>{ if((preset.zones||[]).includes(cb.value)) cb.checked=true; });
        if(preset.depth) depth.value=preset.depth;
        if(preset.ring){ const rb2=tr.querySelector(`input[type="radio"][name="ring"][value="${preset.ring}"]`); if(rb2) rb2.checked=true; }
        if(preset.migration){ const rb3=tr.querySelector(`input[type="radio"][name="migration"][value="${preset.migration}"]`); if(rb3) rb3.checked=true; }
        [...tr.querySelectorAll('input[type="checkbox"][name="extra"]')].forEach(cb=>{ if((preset.extra||[]).includes(cb.value)) cb.checked=true; });
      }

      tr.querySelectorAll("input").forEach(i=> i.addEventListener("change", render));
      return tr;
    }

    document.getElementById("body").appendChild(makeRow());
    render();

    if(window.JFCustomWidget){
      JFCustomWidget.subscribe("ready", function(formId, app){
        try{
          const prev = (app && app.value) ? JSON.parse(app.value) : null;
          if(prev && Array.isArray(prev.rows) && prev.rows.length){
            const tbody = document.getElementById("body"); tbody.innerHTML="";
            prev.rows.forEach(r=> tbody.appendChild(makeRow(r)));
            render();
          }
        }catch(e){}
        JFCustomWidget.subscribe("submit", function(){
          const rows = getRows();
          const paragraphs = rows.map(buildParagraph);
          const conclusion = buildConclusion(rows);
          const value = { rows, paragraphs, text: paragraphs.map(p=>p.text).join("\n\n"), conclusion };
          const valid = rows.length>0;
          JFCustomWidget.sendSubmit({ valid, value: JSON.stringify(value) });
        });
      });
    }
  </script>
</body>
</html>
